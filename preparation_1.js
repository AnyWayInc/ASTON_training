//GitHub
/*
    init - создание репозитория git в директории
    add - добавление файла/ов для индексирования изменений
    commit - добавление комментария к индексированным изменениям и присвоение своего ключа к комиту
    push - отправка локальных файлов на удаленный репозиторий  
    status - состояние текущего репозитория
    config - дает возможность задавать настройки репозитория
    branch - отображает все ветки, при указании имени создает новую ветку, с помощью -d удаляет ее 
    checkout - переключает ветки в репозитории, при помощи -b создает новую ветку и переключает на нее
    merge - слияние изменений 2х веток в 1 коммит 
    remote - соединение удаленного репозитория с локальным
    clone - клонирует существующий удаленный репозиторий
    fetch - получение данных с удаленного репозитория (стягивает изменения)
    pull - содержит в себе fetch и merge, т.е. получение нового состояния в удаленной ветки, а затем добавление данных в локальную ветку
    stash - сохраняет текущую рабочую область в виде стека
    cherry pick - вставка отдельного комита из 1 ветки в другую, -nocommit тоже самое только без комита
    rebase - позволяет перемещать несколько комитов к 1 базовому комиту, при -i открывает интерфейс в консоли где мы выбираем несколько комитов и выстраеваем последовательность и соответсвенно указываем куда их переместить
    reset - позволяет отменять комиты, -hard обновляет а потом сбрасывает раздел -mixed по умолчанию -soft обновляет указатели
    flow - задает строгую модель для управление и расширений проектов
*/


//HTTP, HTTPS
/*
    HTTP - протокол передачи данных в интеренете, использует TCP(TLS - защищенный)
    HTTPS - тот же протокол но зашифрованный, если обычный идет через порт 80,
    то зашифрованный через 443
    HTTP 1.0 - характерезуется линейной отправкой пакетов данных
    HTTP 2.0 - улучшена отправка данных теперь они грузятся паралельно пакетами что ускоряет процесс, а также стал бинарным вместо текстового, заголовок сжимается, отправляется несколько ответов на 1 запрос
    HTTP 3.0 - помимо протокола TCL добавлен протокол QUICK который дополнительно ускоряет отправку данных посредствам
    
    Методы запросов:
    GET -  получить данные с сервера
    POST - отправить данные на сервер
    PUT - замена или создание сущности на сервере
    PATCH - частичное изменение 
    DELETE - удаление
    HEAD - запрашивает ресурс как GET, но без тела ответа
    OPTION - доступные методы на сервере, отсылается неявно это pre ply запрос
    
    В JS запросы обычно отправляются с помощью fetch также есть XMLHttpRequest и используют они подход Ajax
    
    Коды ответов:
    10... - информативные
    20... - успешно
    30... - перенаправление
    40... - ошибка 
    50... - серверные ошибки
*/

//Типы данных
/*
    Примитивы 
    String - включает в себя char + string 
    Boolean - true/false
    Number - включает в себя абсолютно все числа (дробные, с плавующей точкой)
    Null - обозначает пустоту
    Undefined - обозначает незаданное значение
    Symbol - уникальный идентификатор
    BigInt - большое целочисленное значение
    
    Ссылочные
    Object - ссылочный тип данных в которых данные хранятся по типу ключ значение 
    
    JS - язык с динамичиской типизацией, слаботипизированный(любая переменная может содержать значения разных типов)

    Различия var, let, const:
    var - функциональная область видимости всплытие есть если законсолить переменную до ее объявления выдаст undefined
    let - блочная область видимости всплытие есть но с ограничением к примеру
    ,если законсолить переменную до ее объявления то выдаст ошибку, изменяемая
    const - блочная область видимости, также как и с let но конст не изменяется, максимум мутируется

    == - не строгое сравнение
    === - сравнение также по типам

    Autoboxing - когда мы обращаемся к примитиву каким то методом, то есть 
    let a = 5 
    a.toString()
    отработает так как когда мы обращаемся к методу примитива он создает обертку, берет метод задается значение и после чего обертка уберается
    в результате чего получаем undefined
*/

//Abort controller
/*
    Функиця которая прерывает fetch запросы и любые асинхронные задачи

    // прервать через 1 секунду
    let controller = new AbortController();
    setTimeout(() => controller.abort(), 1000);

    try {
        let response = await fetch('/article/fetch-abort/demo/hang', {
            signal: controller.signal
        });
    } catch(err) {
        if (err.name == 'AbortError') { // обработать ошибку от вызова abort()
            alert("Прервано!");
        } else {
            throw err;
        }   
    }
*/

//XMLHttpRequest, fetch 
/*
    XMLHttpRequest - это внедренный API в JS который 
    инкапсулирует логику отправки http запросов без необходимости обновлять страницу

    Для GET мы используем подобную конструкцию
    const Http = new XMLHttpRequest();
    const url='https://jsonplaceholder.typicode.com/users';
    Http.open("GET", url); - создаем запрос
    Http.send(); - отправляем

    Http.onreadystatechange = (e) => { - onreadystatechange по сути статус запроса
      console.log(Http.responseText);  // => получим массив данных в формате JSON
    }

    Для POST вот так
    const user = {
    "name": "Ivan Ivanov",
    "username": "ivan2002",
    "email": "ivan2002@mail.com",
    };

    const Http = new XMLHttpRequest();
    const url='https://jsonplaceholder.typicode.com/users';
    Http.open("POST", url);
    Http.setRequestHeader("Content-Type", "application/json");
    Http.send(JSON.stringify(user));

    Fetch - уже более новая API для отправки асинхронных запросов. 
    Он возвращает промис что позволяет более хорошо обработать запрос

    const url='https://jsonplaceholder.typicode.com/users';
    const user = {
    "name": "Ivan Ivanov",
    "username": "ivan2002",
    "email": "ivan2002@mail.com",
    };
    const otherParam = {
    headers: { - по сути это параметр головы запроса
        "content-type": "application/json; charset=UTF-8",
    },
    body: JSON.stringify(user), - тело запроса 
    method: "POST", - метод отправки
    };

    fetch(url, otherParam) - принимает ссылку куда отправить запрос и другие параметры по желанию, по типу головы и туловища запроса и какой метод использовать
        .then(data => data.json()) - при успешном выполнении resolve и обрабатывает данные в json
        .then(response => console.log(response)) - после чего консолит их 
        .catch(error => console.log(error)); - при reject выводит ошибку
*/

//ООП - Инкапсуляция, полиморфизм, наследование
/*
    ООП - Объектно Ориентированное Программирование - стиль программирования основанный на классах и объектах
    Инкапсуляция - открытые закрытые свойства класса 
    Полиморфизм - по сути это возможность метода возвращать разные значения согласно определенным условиям
    Наследование - возможность создавать классы на основе других
    Абстракция - класс должен представлять такую информацию которая соответствует контексту задачи

    Реализаци ООП в JS
    ООП в прототипном стиле
    
    function Emp(name age){
        this.name = 'a'
        this.age = 'b'
    }

    Emp.prototype.getFullName = function(){
        return this.name
    }
    Т.е. через точку prototype создаем новые методы классу  
    Концепция выбирается из за производительности
    
    ООП на классах 

    ООП в функциональном стиле(устарело)
*/

//Принципы SOLID, KISS, DRY, YAGNI
/*
    SOLID - это принцип разработки
    S - принцип единственной ответсвтенности, то есть 1 класс отвечает за 1 функцию в приложении
    O - принцип открытости/зактрытости, означает что класс должен быть открыт для расширения и закрыт для изменения
    L - принцип подстановки Барбары-Лисков, означает что объект старших класса должен быть заменяем потомком и приложение от этого не изменится
    I - принцип разделения интерфейсов, означает что лучше описать класс большим количиством интерфейсов чем делать 1 общий интерфейс
    D - принцип инверсии зависимости, говорит о том что мы должны полагаться на абстракции а не на реализации, а также детали механизма должены зависить от абстракции, а не наоборот
    KISS - Keep It Simple, Stupid - гласит о том что делай системы как можно проще для восприятия новым людям
    и для простой и надежной работы приложения
    DRY - dont repeat yourself - не повторяй себя, то есть если есть код который используется к примеру
    в 2х функциях лучше тогда его вынести в отдельную функцию и вызывать эту функцию при надобности
    YAGNI - You Aren’t Gonna Need It - вам это не понадобится - говорит о том что нужно писать только тот
    код который будет использоваться в программе 
*/

//Виды функций
/*
    Arrow Function - у него нету this, не может использоваться в виде конструктора, отличается синтаксис, нету всплытия 
    Functional Expression - функциональное выражение отличается от обычной тем что у нее нету своего скоупа и она обычно смотри в глобал в Node и window в браузере, тоесть нету всплытия
    Function Declaration - функция имеет свой скоуп, может всплывать, и может использовать до инициализации и представляется в виде обычной функции с именем
    Named Function Expression - по сути обычная функция записанная в переменную ведет себя как FE
    IIFE - самовызывающаяся функция обычно без имени

    Функции высшего порядка - функции которые принимают или возвращают другие функции
    
    Локальные переменные - это переменные которые видны только в своем блоке кода
    Глобальные переменные - это переменные которые созданы вне области видимости

    Замыкание - это когда вложенная функция имеет доступ к лексическому окружению вышестоящей функции
*/

//Семантические теги в HTML
/*
    Это теги которые описывают содержание в них 
    header - заголовок веб страницы
    section - групирует связный контент вместе 
    article - независимый фрагмент контента
    footer - нижний раздел страницы
    main - основное содержимое страницы
*/

//Веса селекторов 
/*
    1000 - линейный стиль 
    100 - стиль в css по id
    10 - стиль в css по псевдоклассу 
    10 - класс 
    10 - атрибут
    1 - псевдоэлементы
    1 - по тэгам
*/

//Способы позиционирования контента на странице
/*
    position: relative, absolute, static, sticky - css свойство которое определяет положение контента на странице 
    relative - позиционирование относительно его стандартного местоположения на странице , при его использовании можно использовать 
    top,left,bottom,right - параметры которые указывают на смещение местоположения элемента относительно его стандартного 
    absolute - позиционирование относительно родительского элемента, который имеет позиционирование отличное от static не взирая на другие элементы страницы
    при использовании можно также задать параметры top,left,bottom,right
    static - позиционирование элемента в соответствии его места в потоке документа(значение по умолчанию)
    sticky - позиционирование которое фиксируется при скролинге странницы в определенном месте
    fixed - позиционирование относительно окна браузера, т.е. на фиксированном месте страницы независимо от скролинга 
    Также существует способ позиционирование элемента при помощи display
    display: inline, block, flex, grid
    inline - расположение блока элементов в линию в зависимости от их ширины этих элементов
    block - расположение элемента по всей ширине страницы каждый элемент блока с новой строки 
    flex - гибкое расположение элементов за счет правильного расположение элементов на странице 
    grid - это макет для сайта (его схема, проект)
*/

//Прочитать про способы хранения LocalStorage, SessionStorage и Cookie
/*
    localStoraga - хранение данных внутри браузера в виде пары ключ - значение, вне зависимости от того закрыл ли пользователь браузер или нет, потенциально - вечно
    SessionStorage - хранение данных ссесии внутри браузера, очищается при закрытии браузера
    Cookie - хранение данных по средствам закодированной строки и отправки ее в виде ключа при каждом запросе и хранится определенное количество времени которое задал разработчик, потенциально - вечно
*/

//Базовая структура HTML документа:
/*
    <!DOCTYPE html> — объявление типа документа, указывает браузеру на использование последней версии HTML (HTML5).
    <html> — корневой элемент, внутри которого находятся все остальные элементы.
    <head> — содержит мета-информацию о документе, такую как кодировка, заголовок страницы и стили.
    <meta charset="UTF-8"> — указывает кодировку документа.
    <title> — задает заголовок документа, который отображается во вкладке браузера.
    <body> — содержит все видимые элементы страницы, такие как текст, изображения и ссылки.
*/

//БЭМ
/*
    БЭМ - (Блок Элемент Модификатор) - метод разработки программ и интерфейсов, способ описания сущностей, не привязываясь к конкретныйм технологиям реализации.
    Блок - компонент приложения который не связан с другими блоками, также блок может содержать в себе другие блоки и элементы 
    Элемент - часть блока которая выполняет какую либо функцию 
    Модификатор - свойство блока или элемента, отвечающее за внешний вид или поведение блока
*/

//Ссылки, объекты, массивы 
/*
    При создании пустого объекта в нем лежит ссылка на пустой объект
    При создании другой переменной и присваивании ей того объекта в нем будет лежать ссылка на первый объект

    Способы создания объектов 
    Литеральный - самый простой obj = {}
    С помощью функций конструкторо - new Object()
    С помощью Object.create(proto, properties)
    С помощью Object.assign(targetObject - объект куда будут копироваться свойства, ...sourseObjects - сами свойства)

    Дескрипторы объектов:
    value - значение свойства
    writable - если true, то значения можно изменять
    configurable - если true, то можно перезаписывать 
    enumerable - если true, то можно перечислять через for ... of или Object.keys
    get - функция которая будет вызвана при запросе к свойству
    set - функция которая будет вызвана при записи свойства
    Можно изменять через Object.defineProperty(Obj, Имя свойства, descriprtors)

    Object.value - возвращает массив значений объекта
    Object.entries - возвращает массив содержащий свойства объекта в виде пар ключ значение
    Object.keys - возвращает массив содержащий ключи объекта 
    Object.assign - создание объекта путем перечисления свойств других объектов
    Object.create - создание объекта с указанными объектом прототипа и свойствами 
    Object.freeze - замораживает объект, его нельзя не изменить не удалить
    Object.seal - предотвращает удаление свойства объекта другим кодом
    Object.preventExtension - предотвращает расширение объекта

    Копировать объекты можно через assign или spread в некоторых случаях приходится писать функцию глубокого копирования

    При сравнении объектов вернет всегда практически false так как сравниваются не объекты, а ссылки на них

    Массив - это проиндексированный список данных
    Способы создания
    Литеральный - arr = []
    С использованием конструктора - new Array(при указании числа ограничивает длину массива этим числом)
    Через встроенный метод - Array.of(...elements)

    Итерируемые сущности - сущности по которым можно пройтись циклом к примеру 

    Методы массивов
    pop - удаляет последний элемент
    push - добавляет элемент в конец
    reverse - переворачивает массив
    shift - удаляет первый элемент
    unshift - добавляет элемент в начало
    sort - мутирует массив сортировка массива обычно a-b (по возрастанию)
    splice - добавляет или удаляет элементы из массива
    concat - возвращает новый массив, состоящий из данного массива соединенного с другим массивом или значением 
    join - соединение всех элементвом массива в строку 
    includes - содержится в массиве данное значение или нет возвращая boolean
    slice - копируют значение от start до end и возвращает новый массив
    forEach - применяет функцию для каждого элемента в массиве 
    filter - возвращает новый массив со всеми элементами массива удовлетворяющеми условию
    entries - возвращает новый объект пары ключ значение для каждого индекса 
    find - возвращает искомое значение в массиве
    map - возвращает новый массив с результатами вызова указанной функции
    reduce - применяет функцию к аккумулятору и каждому значению массива, сводя все к 1 значению

    Псевдомассив - это объект структура которого совпадает с массивом
*/

//Контекст, его привязка и т.д.
/*
    Контекст выполнения - окружение в котором происходит выполнение кода

    Всего существуют 3 контекста:
    Глобальный 
    Функциональный (Содержит в себе контекст текущий функции, вышестоящей(если есть) и глобальный)
    Eval (про него лучше не говорить)

    Стек выполнения контекста работает по принципу LIFO - Last in First out
    (т.е. вложенные функции выполняются первыми условно говоря)
    
    Жизненный цикл контекста 
    Создание 
    Выполнение
    Удаление

    Сначала определяется this и его привязка
    Затем создается LexicalEnviroment
    После чего окружение переменный VariableEnviroment
    
    Приоритет привязки контекста 
    New
    Явная привязка, т.е. call, bind, apply
    Неявная привязка
    Привязка по умолчанию (высший приоритет)

    this - это объект перед точкой который используется для вызова метода

    call - вызывает функцию с заданным контекстом,
    контекст первым агрументов остальные - аргументы функции
    apply - тоже самое только остальные аргументы передаются в виде массива
    bind - привязывает контекст но не вызывает функцию

    Вызов функции через функцию констуктор new создает this который ссылается на объект который возвращается функцией 
    this у стрелочных функций берется из контекста выше
*/

//Структуры данных, сложность алогоритмов
/*
    Структура данных - это контейнер в котором хранятся данные
    
    Массивы бывают 
    Одномерные
    Многомерные

    Хэш-таблица - это ассоциативный массив который представляет собой пару ключ значение
    Получение/удаление/изменение данных происходит по ключу 

    Стек - список элементов организованных по принципу LIFO

    Очередь - линейная структура данных, где элементы хранятся последовательно, она использует систему FIFO First In First Out 

    Граф - это набор вершин, некоторые из которых соеденины между собой ребрами, вершины - изолированны
    Графы бывают ориентированными и нет

    Дерево - иерархическая структура данных, состоящая из вершин, которые соединяются между собой

    Связанный список - структура данных где элементы хранятся друг за другом
    Бывают односвязными т.е. у каждого элемента есть указатель на следующий 
    И двухсвязный т.е. есть указатель на предыдущий и следующий

    Big O - сложность алгоритма, т.е. как быстро выполняется какой то алгоритм
    Бывают 
    O(1) - 1 простая операция к примеру допустим получить индекс элемента массива
    O(n) - цикл перебора элементов
    O(n^2) - вложенный цикл перебора в цикл к примеру перебор многомерного массива
    O(log n) - бинарная сложность к примеру бинарный поиск, который работает на отсортированном массиве, где на каждой итерации мы убираем половину элементов 
    O(n*log n) - совместно бинарный поиск с вложенным циклом перебора 
*/

//Prototype, классы
/*
    При true || вернет первое значение 
    При true && вернет последнее значение

    prototype - элемент JS который позволяем другим элементам кода наследоваться свойства и методы
    Отличие __proto__ от prototype 
    [[Prototype]] - скрытое свойство объекта который равняется либо ссылки на другой объект либо null
    __proto__ - открытое свойство объектов который может ссылаться на другие объекты
    __proto__ — исторически обусловленный геттер/сеттер для [[Prototype]]
    Т.е. это работает так, что ищет какое то свойство в своем объекте, если его нет,
    то он всплывает в [[Prototype]] и ищет их в других объектах если находит, то выводит его,
    если не находит выводит null

    Отличие prototype от [[Prototype]]
    prototype - создается как свойство функции 
    [[Prototype]] - создается как свойство объекта

    Объектное лучше так как при функциональном создается постоянно функция что засоряет память

    У стрелочных функций нету prototype потому что у них нету своих функций конструкторов, а функция конструктор создает prototype

    Способы управления prototype
    Object.create(proto)
    Object.setPrototypeOf(obj,proto)
    Получение прототипа
    Object.getPrototypeOf(Obj)

    Классы в JS - это разновидность функций
    Весь код в классе неперечисляемый
    Невозможно вызвать класс без new
    Классы помечаются свойством [[FunctionKind]]

    Class Expression - по сути функции, поэтому их можно сохранять в переменные
    Также классы могут иметь доп имя которое создает ссылку на этот класс

    get/set у класса отображаются как get set перед методом 
    Используют для того чтобы скрыть их 

    Расширение классов осуществляется при помощи ключевого слова extends

    class Exp {}
    class Men extends Exp {}

    Super в классах - вызывает конструктор родителя, 
    тем самым изолируем логику выполнения методов в родителе 
    и не дублируем написание этих методов в нашем классе
*/

//Event Loop, ассинхронность в JS, Promise
/*
    JS - синхронный(выполняет код последовательно) и однопоточный язык

    Стек вызова работает по принципу LIFO

    Асинхронность - модель поведения, когда определенные задачи выполяются на фоне

    Event Loop - бесконечный событийный цикл, делает возможным выполнение ассинхронных задач

    Состоит из 
    Heap - место хранения объектов
    Stack - стек вызова
    Web API - набор инструментов из браузера
    Callback queue - очередь задач

    Callback queue состоит из микро задач и макро задач

    Микро - callback функции Promise Observer
    Макро - setTimeout setInterval

    Promise - объект у которого есть 3 состояния 
    pending - ожидание
    fullfilled - завершен успешно
    rejected - выполнен с ошибкой

    Экземпляры/методы Promise
    then - принимает resolve и reject т.е. при успешном выполнении предыдущей операции
    then можно использовать и для обработки неудачных сценариев 
    catch - принимает reject т.е. при ошибки
    finally - ничего не принимает от цепочки Promise используется 
    когда нужно независимо от ситуации выполнить какое то стороннее действие 

    Статичный методы Promice

    Promise.all - запуск нескольких Promise возвращая либо 1 ошибку либо массив успешных
    Promise.race - запуск нескольких Promise возвращая 1 ошибку или 1 выполненный
    Promise.allSetted - запуск нескольких Promise возвращая массив объектного вида со всеми Promise
    Promise.any - возвращает 1 успешный Promise
    Promise.resolve - создает успешно выполненный Promise с заданным значением
    Promise.reject - создает неудачно выполненный Promise с заданной ошибкой

    Promise может вернуть либо какое то значение либо ошибку или другой промис 

    Проваливание Promise происходит когда в then попадает не callback а новый Promise 
    Все что находится в этом then представляется в виде значения null

    Ошибки в асинхроне обрабатываются при помощи try{}catch(error){}
*/

//DOM, BOM
/*
    DOM - объектная модель документа которая создается в процессе загрузки страницы
    Т.е. представление html страницы в виде иерархии объектов
    Главный элемент страницы - document - через него можно обратиться к любому элементу страницы
    Document включает в себя функции по созданию удалению контента
    Кроме этого через document можно получить информацию о самом документе

    BOM - совокупность инструментов используемых браузером
    Набор функций и объектов предоставляеме браузером
    Является спецификацией HTML

    DOM дерево - иерархия элементов HTML страницы, тэг являются элементами,
    текст и комментарии являются узлами DOM дерева, script в виде текста
    Узлы DOM дерева состоит 
    Обычные узлы 
    Узлы-элементы 

    Элементы - это все теги
    ParentNode ParentElement - свойства для получения родительских элементов
    previousSubling nextElementSubling - свойства для получения соседних элементов/узлов
    childNodes children firstChild lastElementChold - свойства для получения дочерних элементов

    Методы поиска элементов в document
    getElementById - по id либо null либо непредсказуемый элемент
    getElementsByName - по атрибуту name либо пустая коллекция либо не пустая
    getElementsByClassName - по классу либо пустая коллекция либо нет
    getElementsByTagName - по тэгу либо пустая коллекция либо нет
    querySelector - по селектору .-класс #-id вернет первый элемент или null

    getElementsBy* - живая коллекция, т.е. сразу реагирует на изменения в документе
    и отображает текущее состояние документа
    querySelector - неживая т.е. по сути делает снимок текущего состояния документа
    на момент осуществления запроса

    Манипуляции над DOM
    document.createElement(tagName,option) - создание элемента 
    document.createComment(data) - создание комментария

    Вставка узлов 
    node.append - вставка в конец
    node.prepend - вставка в начало
    node.before - вставка перед node
    node.after - вставка после node
    node.replaceWith - вставка вместо node

    Вставка HTML фрагментов осуществляется через elem.innerHTML 
    его можно изменить соответственно изменится сам элемент

    Удаление узлов осуществляется через node.remove() можно также через innerHTML и textContent

    Для клонирование используется метод node.cloneNode(deep)
    при deep - false копируется только сам элемент 

    Изменение атрибутов 
    elem.setAttribute - установить аттрибт
    elem.getAttribute - получить аттрибут
    elem.hasAttribute - есть ли аттрибут
    elem.removeAttribute - удалить аттрибут

    Классы 
    elem.classList.add - добавить класс
    elem.classList.remove - убрать класс
    elem.classList.toggle - если класс есть то удалить, если нет добавить
    elem.classList.contains - есть ли класс

    Стили
    elem.style.СТИЛЬ - устанавливает стиль элементу
    elem.style.cssText - заменяет стили в css на это 
    window.getComputedStyle(elem, pseudo) - получить стили элемента в виде объекта свойство значение 
    pseude нужен для получение стилей :after к примеру
*/

//События
/*
    Событие - это сигнал браузера что на странице что то произошло 

    У каждого события 3 стадии
    Стадия погружения(перехвата) - для обработки этого события используется addEventListener(_,_,option) 
    на этой фазе вызываются все обработчики связанные на этом элементе
    Стадия цели - фокусируемся на целевом элементе (event.target - элемент на который ссылается обработчик
    event.currentTarget - ссылается на элемент на котором сработал обработчик) 
    Стадия всплытия - реализация действия

    Обработчики события 
    В теге on* (click,blur,enter) и т.д.
    Указать с помощью аттрибута в виде btn.onclick
    Через addEventListener, прнимает 3 агрумента
    eventName - названия события
    eventHandler - функция обработчик
    options - необязательный параметр

    Удалить addEventListener можно через removeEventListener который удаляет обработчик по ссылке
    Или при передачи 3го параметра once: true - отработает 1 раз и удалится 
    При удалении надо писать тот же ивент и туже используемую функцию и лучше функцию вынести отдельно

    В addEventListener 2 аргументом можно передать объект

    Объекты события
    event.target
    event.currentTarget
    event.type - тип события в виде строки
    
    Методы объекта событий
    event.preventDefault - отмена действия по умолчанию     
    event.stopPropagation - прекращение дальнейшего распространения события
    event.stopImmediatePropagation - аналогично выше но предотвращает вызов других обработчиков на этом элементе

    Также отменить действие можно при помощи возвращения false из аттрибута тега

    Функциональное праграммирование - написание кода через функции

    Паттерны ФП
    Функции высшего порядка - функции которые принимают в себя функции или возвращают их
    Чистые функции - всегда возвращает предсказуемый результат 
    не используя глобальные значения, не модифицируя значения снаружи, не записывание данных в файлы

    Каррирование - преобразование функций с множеством аргументов в набор вложенных функций с 1 аргументом

    async - скрипт независим
    Страница не ждет асинхронные скрипты, как загрузится так и выполнится независимо друг от друга

    defer - загружать скрипт в фоновом режиме, а после загрузки страницы запустить скрипт
    Не блокирует страницу 
    Выполняется когда DOM дерево готово

    Critical Render Path - последовательность шагов для отрисовки страницы
    Построение DOM
    Построение CSSOM
    Запуск JS
    Создание Render дерева (захватывает только видимый контент)
    Генерация раскладки (vueport - размеры странички)
    Отрисовка (сложение всех этапов в 1 кучу)
*/
